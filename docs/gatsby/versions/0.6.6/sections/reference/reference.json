{
  "parents": [],
  "prev": {
    "link": "../../api/apidocs/dagster_dask/",
    "title": "dagster_dask"
  },
  "next": { "link": "../../deploying/", "title": "Deploying Dagster" },
  "title": "Reference",
  "meta": {},
  "body": "<div class=\"section\" id=\"reference\">\n<h1>Reference<a class=\"headerlink\" href=\"#reference\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<p>As you get started with Dagster, you\u2019ll find that there are a number of important concepts\nunderpinning the system. Some of these concepts, like DAGs, will undoubtably be familiar\nif you\u2019ve previously worked with tools like Airflow. However, Dagster has some important differences\nfrom other workflow systems to facilitate operating at a higher level of abstraction.</p>\n<div class=\"section\" id=\"solid\">\n<h2>Solid<a class=\"headerlink\" href=\"#solid\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<a class=\"reference internal image-reference\" href=\"../../../_images/solid.png\"><img alt=\"../../../_images/solid.png\" class=\"align-center\" src=\"../../../_images/solid.png\" style=\"width: 152.8px; height: 128.0px;\" /></a>\n<p>A solid is a functional unit of computation with defined inputs and outputs. Solids can be strung\ntogether into <a class=\"reference external\" href=\"#pipeline\">pipelines</a> by defining <a class=\"reference external\" href=\"#dependency-definition\">dependencies</a>\nbetween their inputs and outputs.  Solids are reusable, and instances of a solid may appear many\ntimes in a given pipeline, or across many different pipelines.</p>\n<p>Solids often wrap code written in or intended to execute in other systems (e.g., SQL statements,\nJupyter notebooks, or Spark jobs written in Scala), providing a common interface for defining,\norchestrating, and managing data processing applications with heterogeneous components.</p>\n<p>Solids can optionally define the types of their inputs and outputs, and can define a typed schema\nso that their inputs can be read from external configuration files. Solids can also enforce\n<a class=\"reference external\" href=\"#expectation\">expectations</a> on their inputs and outputs.</p>\n<p>Solids are defined using the <a class=\"reference internal\" href=\"../../api/apidocs/solids/#dagster.lambda_solid\" title=\"dagster.lambda_solid\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">&#64;lambda_solid</span></code></a> or\n<a class=\"reference internal\" href=\"../../api/apidocs/solids/#dagster.solid\" title=\"dagster.solid\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">&#64;solid</span></code></a> decorators, or using the underlying\n<a class=\"reference internal\" href=\"../../api/apidocs/solids/#dagster.SolidDefinition\" title=\"dagster.SolidDefinition\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">SolidDefinition</span></code></a> class. These APIs wrap an underlying\n<cite>compute function</cite>, making its metadata queryable by higher-level tools.</p>\n<p>You can check out <a class=\"reference external\" href=\"../learn/guides/solid/solid.html\">the solid guide</a> for a deeper dive on\nsolids and how they can be used.</p>\n</div>\n<div class=\"section\" id=\"compute-function\">\n<h2>Compute Function<a class=\"headerlink\" href=\"#compute-function\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<a class=\"reference internal image-reference\" href=\"../../../_images/compute_fn.png\"><img alt=\"../../../_images/compute_fn.png\" class=\"align-center\" src=\"../../../_images/compute_fn.png\" style=\"width: 235.60000000000002px; height: 107.60000000000001px;\" /></a>\n<p>The user-supplied function which forms the heart of a solid definition. The compute functions are\nthe business logic defined by you as the user; this business logic is what will be executed when the\nsolid is invoked by the Dagster engine.</p>\n</div>\n<div class=\"section\" id=\"outputs\">\n<h2>Outputs<a class=\"headerlink\" href=\"#outputs\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<a class=\"reference internal image-reference\" href=\"../../../_images/outputs.png\"><img alt=\"../../../_images/outputs.png\" class=\"align-center\" src=\"../../../_images/outputs.png\" style=\"width: 220.8px; height: 118.4px;\" /></a>\n<p>An output is how a solid\u2019s compute function communicates the name and value of an output to Dagster.</p>\n<p>Solid compute functions are expected to yield a stream of outputs. Implementers of a solid must\nensure their compute function yields <a class=\"reference internal\" href=\"../../api/apidocs/solids/#dagster.Output\" title=\"dagster.Output\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Output</span></code></a> objects:</p>\n<div class=\"highlight-python notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"nd\">@solid</span><span class=\"p\">(</span><span class=\"n\">output_defs</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">OutputDefinition</span><span class=\"p\">(</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"s1\">&#39;one&#39;</span><span class=\"p\">),</span> <span class=\"n\">OutputDefinition</span><span class=\"p\">(</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"s1\">&#39;two&#39;</span><span class=\"p\">)])</span>\n<span class=\"k\">def</span> <span class=\"nf\">return_one_and_two</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">):</span>\n    <span class=\"k\">yield</span> <span class=\"n\">Output</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">&#39;one&#39;</span><span class=\"p\">)</span>\n    <span class=\"k\">yield</span> <span class=\"n\">Output</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"s1\">&#39;two&#39;</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>By referring to the names of these outputs, downstream solids can selectively depend on certain\noutputs of a solid and not others.</p>\n<p>In the common case where only a single output is yielded, Dagster provides sugar allowing the user\nto just return a value instead of yielding it, and will automatically wrap the returned value in a\n<a class=\"reference internal\" href=\"../../api/apidocs/solids/#dagster.Output\" title=\"dagster.Output\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Output</span></code></a> class:</p>\n<div class=\"highlight-python notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"nd\">@solid</span>\n<span class=\"k\">def</span> <span class=\"nf\">return_one</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"mi\">1</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"pipelines-dags\">\n<span id=\"pipeline\"></span><h2>Pipelines &amp; DAGs<a class=\"headerlink\" href=\"#pipelines-dags\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<a class=\"reference internal image-reference\" href=\"../../../_images/pipeline.png\"><img alt=\"../../../_images/pipeline.png\" class=\"align-center\" src=\"../../../_images/pipeline.png\" style=\"width: 374.8px; height: 223.60000000000002px;\" /></a>\n<p>DAG is short for <cite>directed acyclic graph</cite>. In this context, we are concerned with graphs where the\nnodes are computations and the edges are dependencies between those computations. The dependencies\nare <cite>directed</cite> because the outputs of one computation are the inputs to another.\nThese graphs are <cite>acyclic</cite> because there are no circular dependencies \u2013 in other words, the graph\nhas a clear beginning and end, and we can always figure out what order to execute its nodes in.</p>\n<p>In Dagster, pipelines are directed acyclic graphs (DAGs) of solids \u2013 that is, they are made up of a\nnumber of solids which have data <a class=\"reference external\" href=\"#dependency-definition\">dependencies</a> on each other (but no\ncircular dependencies).</p>\n<p>These pipelines are created with the Dagster <a class=\"reference internal\" href=\"../../api/apidocs/pipeline/#dagster.pipeline\" title=\"dagster.pipeline\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">&#64;pipeline</span></code></a> decorator. Any\nsolids invoked from within a pipeline definition function will automatically be added to the\npipeline DAG.</p>\n<p>Paired with appropriate configuration, the pipeline can be compiled by the Dagster engine into an\nexecution plan that is executable on various compute substrates. To support these substrates,\npipeline execution is managed via <a class=\"reference internal\" href=\"../../api/apidocs/pipeline/#dagster.ModeDefinition\" title=\"dagster.ModeDefinition\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ModeDefinition</span></code></a>, which permit\nspecifying different modes for execution.</p>\n<p>Concretely, a pipeline might include mode definitions for local testing (where databases and\nother resources will be mocked, in-memory, or local) and for running in production (where resources\nwill require different credentials and expose configuration options). When a pipeline is compiled\nwith a config corresponding to one of these modes, it yields an execution plan suitable for the\ngiven environment. The <a class=\"reference external\" href=\"../learn/tutorial/resources.html#modes\">tutorial on Modes</a> showcases how\nyou can combine resources and modes in pipeline execution.</p>\n</div>\n<div class=\"section\" id=\"dependencies\">\n<span id=\"dependency-definition\"></span><h2>Dependencies<a class=\"headerlink\" href=\"#dependencies\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<a class=\"reference internal image-reference\" href=\"../../../_images/dependency.png\"><img alt=\"../../../_images/dependency.png\" class=\"align-center\" src=\"../../../_images/dependency.png\" style=\"width: 347.6px; height: 149.20000000000002px;\" /></a>\n<p>Solids are linked together into <a class=\"reference external\" href=\"#pipeline\">pipelines</a> by defining the dependencies between\ntheir inputs and outputs. An important difference between Dagster and other workflow systems is that\nin Dagster, dependencies are expressed as data dependencies, not how or when they execute.</p>\n<p>This difference enables Dagster to support a much richer modeling of dependencies \u2013 instead of\nmerely ensuring that the order of execution is correct, dependencies in Dagster provide a variety of\ncompile- and run-time checks.</p>\n<p>Dependencies are expressed using Dagster\u2019s simple function invocation DSL; you can check out the\n<a class=\"reference external\" href=\"../learn/tutorial/actual_dag.html\">tutorial</a> for an example of composing solids with\ndependencies.</p>\n</div>\n<div class=\"section\" id=\"resources\">\n<h2>Resources<a class=\"headerlink\" href=\"#resources\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<a class=\"reference internal image-reference\" href=\"../../../_images/resource.png\"><img alt=\"../../../_images/resource.png\" class=\"align-center\" src=\"../../../_images/resource.png\" style=\"width: 362.0px; height: 218.0px;\" /></a>\n<p>Resources are pipeline-scoped, and are typically used to expose features of the execution\nenvironment (like EMR, Redshift, Spark, BigQuery, etc.) to solids during pipeline execution.\nResources bound to pipeline execution through modes, and can also clean up after execution resolves.\nThey are typically defined using the <a class=\"reference internal\" href=\"../../api/apidocs/pipeline/#dagster.resource\" title=\"dagster.resource\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">&#64;resource</span></code></a> decorator or using the\n<code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ResourceDefinition</span></code> class directly.</p>\n</div>\n<div class=\"section\" id=\"repository\">\n<h2>Repository<a class=\"headerlink\" href=\"#repository\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<a class=\"reference internal image-reference\" href=\"../../../_images/repository.png\"><img alt=\"../../../_images/repository.png\" class=\"align-center\" src=\"../../../_images/repository.png\" style=\"width: 602.8000000000001px; height: 175.20000000000002px;\" /></a>\n<p>A repository is a collection of pipelines that can be made available to the Dagit UI and other\nhigher-level tools. Repositories are defined using the\n<a class=\"reference internal\" href=\"../../api/apidocs/pipeline/#dagster.RepositoryDefinition\" title=\"dagster.RepositoryDefinition\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">RepositoryDefinition</span></code></a> class, and made available to\nhigher-level tools with a special <code class=\"docutils literal notranslate\"><span class=\"pre\">repository.yaml</span></code> file that tells the tools where to look for a\nrepository definition.</p>\n</div>\n<div class=\"section\" id=\"composite-solids\">\n<h2>Composite Solids<a class=\"headerlink\" href=\"#composite-solids\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<a class=\"reference internal image-reference\" href=\"../../../_images/composites.png\"><img alt=\"../../../_images/composites.png\" class=\"align-center\" src=\"../../../_images/composites.png\" style=\"width: 417.6px; height: 267.6px;\" /></a>\n<p>To help manage the level of complexity that data applications tend to reach, dagster provides a unit\nof abstraction for composing a solid from other solids. We call this type of solid a <strong>Composite\nSolid</strong>.</p>\n<dl class=\"simple\">\n<dt>This ability to compose solids can be used to:</dt><dd><ul class=\"simple\">\n<li><p>organize large or complicated graphs</p></li>\n<li><p>abstract away complexity</p></li>\n<li><p>wrap re-usable solids with domain specific information</p></li>\n</ul>\n</dd>\n</dl>\n<p>Refactoring a DAG of solids using composites is a very familiar experience to refactoring code\nwith functions.</p>\n<p>Defining a composite solid is similar to defining a pipeline, but can also provide mapping\ninformation to control how data and configuration flows in and out of its inner graph of solids. You\ncan see an example of composition in action in the\n<a class=\"reference external\" href=\"../learn/tutorial/composite_solids.html\">tutorial</a>.</p>\n</div>\n<div class=\"section\" id=\"dagster-types\">\n<h2>Dagster Types<a class=\"headerlink\" href=\"#dagster-types\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>The Dagster type system allows authors of solids and pipelines to optionally and gradually define\nthe types of the data that flows between solids, and so to introduce compile-time and runtime checks\ninto their pipelines.</p>\n<p>Types also allow for custom materialization, and are typically defined using the\n<a class=\"reference internal\" href=\"../../api/apidocs/types/#dagster.dagster_type\" title=\"dagster.dagster_type\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">&#64;dagster_type</span></code></a> decorator or the\n<a class=\"reference internal\" href=\"../../api/apidocs/types/#dagster.as_dagster_type\" title=\"dagster.as_dagster_type\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">as_dagster_type</span></code></a> API. It is also possible to inherit from\n<code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">RuntimeType</span></code> directly.</p>\n</div>\n<div class=\"section\" id=\"environment-config\">\n<h2>Environment Config<a class=\"headerlink\" href=\"#environment-config\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Environment config defines the external environment with which a pipeline will interact for a given\nexecution plan. Environment config can be used to change solid behavior, define pipeline- or\nsolid-scoped resources and data that will be available during execution, or even shim solid inputs.</p>\n<p>Environment config is complementary to data (solid inputs and outputs) \u2013 think of inputs and\noutputs as specifying <cite>what</cite> data a pipeline operates on, and config as specifying <cite>how</cite> it\noperates.</p>\n<p>Concretely, imagine a pipeline of solids operating on a data warehouse. The solids might emit and\nconsume table partition coordinates and aggregate statistics as inputs and outputs \u2013 the data on\nwhich they operate. Environment config might specify how to connect to the warehouse (so that the\npipeline could also operate against a local test database), how to log the results of intermediate\ncomputations, or where to put artifacts like plots and summary tables.</p>\n</div>\n<div class=\"section\" id=\"configuration-schemas\">\n<h2>Configuration Schemas<a class=\"headerlink\" href=\"#configuration-schemas\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>In Dagster, configuration is explicitly typed with configuration schemas. Configuration schemas\ndefine how users can config pipelines. They tell the Dagster engine how to type check user-supplied\nenvironment config against the pipeline and enable many errors to be caught with rich messaging at\ncompile time.</p>\n<p>When creating resources <a class=\"reference internal\" href=\"../../api/apidocs/solids/#dagster.solid\" title=\"dagster.solid\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">&#64;resource</span></code></a>, solids <a class=\"reference internal\" href=\"../../api/apidocs/solids/#dagster.solid\" title=\"dagster.solid\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">&#64;solid</span></code></a>, or\nloggers <a class=\"reference internal\" href=\"../../api/apidocs/pipeline/#dagster.logger\" title=\"dagster.logger\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">&#64;logger</span></code></a>, you can supply a configuration schema to define the\navailable configuration for that object.</p>\n</div>\n<div class=\"section\" id=\"execution-plan\">\n<h2>Execution Plan<a class=\"headerlink\" href=\"#execution-plan\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>An execution plan is a concrete plan for executing a DAG of execution steps created by compiling a\npipeline and a config. The execution plan is aware of the topological ordering of the execution\nsteps, enabling physical execution on one of the available executor engines (e.g., in-process,\nmultiprocess, using Airflow).</p>\n<p>Users do not directly instantiate or manipulate execution plans.</p>\n</div>\n<div class=\"section\" id=\"execution-step\">\n<h2>Execution Step<a class=\"headerlink\" href=\"#execution-step\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Execution steps are concrete computations. When a pipeline is compiled with an environment config,\neach solid is compiled into one or more corresponding execution steps. Some execution steps are\ngenerated in order to compute the core compute functions of solids, but execution steps may also be\ngenerated in order to materialize outputs, check expectations against outputs, etc.</p>\n<p>Users do not directly instantiate or manipulate execution steps.</p>\n</div>\n<div class=\"section\" id=\"dagster-event\">\n<h2>Dagster Event<a class=\"headerlink\" href=\"#dagster-event\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>When a pipeline is executed, a stream of events communicate the progress of its execution. This\nincludes top level events when the pipeline starts and completes, when execution steps succeed,\nfail, or are skipped due to upstream failures, and when outputs are generated and materialized.</p>\n<p>Users do not directly instantiate or manipulate Dagster events, but they are consumed by the GraphQL\ninterface that supports the Dagit tool.</p>\n</div>\n</div>\n",
  "metatags": "",
  "rellinks": [
    ["genindex", "General Index", "I", "index"],
    ["py-modindex", "Python Module Index", "", "modules"],
    ["sections/deploying/index", "Deploying Dagster", "N", "next"],
    ["sections/api/apidocs/dagster_dask", "dagster_dask", "P", "previous"]
  ],
  "sourcename": "sections/reference/reference.rst.txt",
  "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">Reference</a><ul>\n<li><a class=\"reference internal\" href=\"#solid\">Solid</a></li>\n<li><a class=\"reference internal\" href=\"#compute-function\">Compute Function</a></li>\n<li><a class=\"reference internal\" href=\"#outputs\">Outputs</a></li>\n<li><a class=\"reference internal\" href=\"#pipelines-dags\">Pipelines &amp; DAGs</a></li>\n<li><a class=\"reference internal\" href=\"#dependencies\">Dependencies</a></li>\n<li><a class=\"reference internal\" href=\"#resources\">Resources</a></li>\n<li><a class=\"reference internal\" href=\"#repository\">Repository</a></li>\n<li><a class=\"reference internal\" href=\"#composite-solids\">Composite Solids</a></li>\n<li><a class=\"reference internal\" href=\"#dagster-types\">Dagster Types</a></li>\n<li><a class=\"reference internal\" href=\"#environment-config\">Environment Config</a></li>\n<li><a class=\"reference internal\" href=\"#configuration-schemas\">Configuration Schemas</a></li>\n<li><a class=\"reference internal\" href=\"#execution-plan\">Execution Plan</a></li>\n<li><a class=\"reference internal\" href=\"#execution-step\">Execution Step</a></li>\n<li><a class=\"reference internal\" href=\"#dagster-event\">Dagster Event</a></li>\n</ul>\n</li>\n</ul>\n",
  "display_toc": true,
  "page_source_suffix": ".rst",
  "current_page_name": "sections/reference/reference",
  "sidebars": ["globaltoc.html", "searchbox.html"],
  "customsidebar": null,
  "alabaster_version": "0.7.12"
}
