---
title: "Tutorial, part seven: Managing your own I/O | Dagster Docs"
description: Learn how to use I/O managers to save your data.
---

# Tutorial, part 7: Managing your own I/O

In this section, you'll take a step back and learn how to use more of Dagster's versatility without using every feature provided to you. Throughout this tutorial, you've learned multiple Dagster concepts that explain how Dagster can manage functionality on your behalf, ex. I/O managers to read and write from storage.

When building the dictionary or word counts, the `most_frequent_words` asset currently uses a static list of stopwords to decide what words to ignore. Youâ€™ll notice that despite the length of the list, many unhelpful words and prepositions are still not filtered out. Youâ€™d like to ignore those words. To scale this properly, youâ€™ll use a CSV of stopwords found on the internet, use it for `most_frequent_words`, and update it before the refresh to ensure that your list of stopwords is up-to-date.

You'll create assets to manage reading and writing from storage on your own. This is useful for multiple purposes, such as:

- Your pipeline manages I/O on its own by using other libraries/tools that write to storage.
- You want to run a SQL query that creates or updates a table on the database.
- Adjacent to the above point, your I/O manager is batch-oriented, and the data loaded would not fit into memory.
- Writing your pipeline using I/O managers is possible, but you don't want use this Dagster-specific concept. For example, you have an existing pipeline and don't want to refactor it.

By the end of this section, you'll also have assets that depend on other assets without loading the dependent asset's data into memory.

## Step 1: Creating an asset without an I/O Manager

Many valid situations exist where you would want to avoid using an I/O manager to write an asset back to memory. One is when the asset is already saved in the asset function definition without having to return the data.

In your `assets.py`, create a new asset called `stopwords_zip` by copying and pasting the code below:

```python file=/tutorial/managing_your_own_io/assets.py startafter=start_stopwords_zip endbefore=end_stopwords_zip
import urllib.request  # Addition: new import at the top of `assets.py`

from dagster import asset


@asset
def stopwords_zip() -> None:
    urllib.request.urlretrieve(
        "https://docs.dagster.io/assets/stopwords.zip,data/stopwords.zip",
    )
```

In this asset, youâ€™ll download a file from the internet. Dagster stores this file on the machine it is running on. There are two key differences between the assets youâ€™ve written so far and this asset:

- **It doesn't have a return statement.** Because the zip file is downloaded directly onto the machine, there is no need to return data.
- **It has a `None` annotation for its return type.** This tells Dagster that it shouldnâ€™t use an I/O manager because there is no data to write back.

These are the only two changes required to have an asset not use an I/O manager.

Refresh your code location, observe the new asset, and materialize it as you have with the previous assets. You can confirm that this works by finding the `stopwords.zip` in the `/data` directory made in the **Saving your data** section of the tutorial.

## Step 2: Depend on an asset without loading it

Youâ€™ll now unzip the zip file asset you made and extract the CSV from it. This CSV will be a new asset that depends on the zip file asset you downloaded.

By default, an asset will load its dependencies into memory when it materializes. However, there are situations where you would want to avoid doing this. As previously mentioned, if your data is too large to fit into memory, or if you didnâ€™t use an I/O manager for the dependency, you would not want to try loading the dependency.

To tell an asset not to load a dependency into memory when materializing, you can use the `@asset` decoratorâ€™s `non_argument_deps` parameter to establish the dependency instead of passing it in as an argument of the assetâ€™s function definition.

Copy the code below into your `assets.py` to create a new asset called `stopwords_csv`:

```python file=/tutorial/managing_your_own_io/assets.py startafter=start_stopwords_csv endbefore=end_stopwords_csv
import zipfile  # Note: remember to add imports to the top of the file


@asset(non_argument_deps={"stopwords_zip"})
def stopwords_csv() -> None:
    with zipfile.ZipFile("data/stopwords.zip", "r") as zip_ref:
        zip_ref.extractall("data")
```

Reload your code location, observe the new `stopwords_csv` asset, and notice how it is dependent on the `stopwords_zip` asset.

## Step 3: Combining assets with and without I/O managers

Now that youâ€™ve made two assets that donâ€™t use I/O managers, youâ€™ll connect the `stopwords_csv` asset to your `most_frequent_words` asset to use a more comprehensive list of stopwords.

When defining an asset, you can combine assets that use I/O managers with assets that donâ€™t. Update your `most_frequent_words` asset by replacing the static list of stopwords. Replace it with `stopwords_csv` by updating your code to match the below:

```python file=/tutorial/managing_your_own_io/assets.py startafter=start_updated_most_frequent_words endbefore=end_updated_most_frequent_words
import csv  # Note: Remember to add all new imports to the top


@asset(
    non_argument_deps={"stopwords_csv"},  # Addition: added the dependency
)
def most_frequent_words(topstories):
    # stopwords = ["a", "the", "an", "of", "to", "in", "for", "and", "with", "on", "is"]
    # Remove the line above

    # Replace the with the two lines below
    with open("data/stopwords.csv", "r") as f:
        stopwords = {row[0] for row in csv.reader(f)}


# ...

# Keep the rest of the function the same
```

To validate that this worked, materialize your entire asset graph to see `most_frequent_words` depend on the `stopwords_csv` asset

## Next Steps

Congratulations! ðŸŽ‰ You've written your first pipeline in Dagster!

In this section, you learned how to create assets without an I/O manager and have them as dependencies on other assets. You also learned how to combine assets that use I/O managers with assets that don't.

Now that you've completed the tutorial, find out what else you can do with our [Next steps](/tutorial/next-steps).
