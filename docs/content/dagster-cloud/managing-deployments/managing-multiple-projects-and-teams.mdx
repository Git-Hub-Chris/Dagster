---
title: "Managing multiple projects & teams in Dagster Cloud | Dagster Docs"
description: "How to set up and manage multiple projects with Dagster Cloud Hybrid deployments."
---

# Managing multiple projects & teams in Dagster Cloud

<Note>This guide is applicable to Dagster Cloud.</Note>

In this guide, we'll cover some strategies for managing multiple projects and teams in a Dagster Cloud account.

If you require isolation between your execution context, see [Strategies for execution context isolation](#strategies-for-execution-context-isolation).

---

## Separating code bases

If you want to manage complexity or divide your work into areas of responsibility, consider isolating your code bases into multiple projects with:

- Multiple directories in a single repository, or
- Multiple repositories

Refer to the following table for more information, including the pros and cons of each approach.

<table
  className="table"
  style={{
    width: "100%",
  }}
>
  <thead>
    <tr>
      <th
        style={{
          width: "14%",
        }}
      >
        Approach
      </th>
      <th
        style={{
          width: "43%",
        }}
      >
        Multiple directories in a single repository
      </th>
      <th>Multiple repositories</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <strong>How it works</strong>
      </td>
      <td>
        You can use a single repository to manage multiple projects by placing
        each project in a separate directory. Depending on your VCS, you may be
        able to set{" "}
        <a href="https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners">
          code owners
        </a>{" "}
        to restrict who can modify each project.
      </td>
      <td>
        For stronger isolation, you can use multiple repositories to manage
        multiple projects.
      </td>
    </tr>
    <tr>
      <td>
        <strong>Pros</strong>
      </td>
      <td>
        <ul
          style={{
            marginTop: "0px",
          }}
        >
          <li
            style={{
              marginTop: "0px",
            }}
          >
            Simple to implement
          </li>
          <li>Facilitates code sharing between projects</li>
        </ul>
      </td>
      <td>
        <ul
          style={{
            marginTop: "0px",
          }}
        >
          <li
            style={{
              marginTop: "0px",
            }}
          >
            Stronger isolation between projects and teams
          </li>
          <li>
            Each project has its own CI/CD pipeline and be deployed
            independently
          </li>
          <li>Dependencies between projects can be managed independently</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>
        <strong>Cons</strong>
      </td>
      <td>
        <ul
          style={{
            marginTop: "0px",
          }}
        >
          <li
            style={{
              marginTop: "0px",
            }}
          >
            All projects share the same CI/CD pipeline and cannot be deployed
            independently
          </li>
          <li>
            Shared dependencies between projects may cause conflicts and require
            coordination between teams
          </li>
        </ul>
      </td>
      <td>
        Code sharing between projects require additional coordination to publish
        and reuse packages between projects
      </td>
    </tr>
  </tbody>
</table>

### Deployment configuration

Whether you use a single repository or multiple, you can use a [`dagster_cloud.yaml` file](/dagster-cloud/managing-deployments/dagster-cloud-yaml) to define the code locations to deploy. For each repository, follow the [steps appropriate to your CI/CD provider](/dagster-cloud/getting-started#step-4-configure-cicd-for-your-project) and include only the code locations that are relevant to the repository in your CI/CD workflow.

#### Example with GitHub CI/CD on Hybrid deployment

1. **For each repository**, use the CI/CD workflow provided in [Dagster Cloud Hybrid quickstart repository](https://github.com/dagster-io/dagster-cloud-hybrid-quickstart/blob/main/.github/workflows/dagster-cloud-deploy.yml).

2. **For each project in the repository**, configure a code location in the [`dagster_cloud.yaml` file](/dagster-cloud/managing-deployments/dagster-cloud-yaml):

   ```yaml
   # dagster_cloud.yml

   locations:
     - location_name: project_a
       code_source:
         package_name: project_a
       build:
         # ...
     - location_name: project_b
       code_source:
         package_name: project_b
       build:
         # ...
   ```

3. In the repository's `dagster-cloud-deploy.yml` file, modify the CI/CD workflow to deploy all code locations for the repository:

   ```yaml
   # .github/workflows/dagster-cloud-deploy.yml

   jobs:
     dagster-cloud-deploy:
       # ...
       steps:
         - name: Update build session with image tag for "project_a" code location
           id: ci-set-build-output-project-a
           if: steps.prerun.outputs.result != 'skip'
           uses: dagster-io/dagster-cloud-action/actions/utils/dagster-cloud-cli@v0.1
           with:
             command: "ci set-build-output --location-name=project_a --image-tag=$IMAGE_TAG"

         - name: Update build session with image tag for "project_b" code location
           id: ci-set-build-output-project-b
           if: steps.prerun.outputs.result != 'skip'
           uses: dagster-io/dagster-cloud-action/actions/utils/dagster-cloud-cli@v0.1
           with:
             command: "ci set-build-output --location-name=project_b --image-tag=$IMAGE_TAG"
         # ...
   ```

---

## Strategies for execution context isolation

Separating execution context between projects can have several motivations:

- facilitate separation of duty between teams to prevent access to sensitive data
- different compute environments and requirements (different architecture, cloud provider, etc.)
- prevent noisy neighbors effects (a project with a large number of runs can impact the performance of other projects)

There are three isolation levels you may want to consider:

### Code location isolation

<Image
alt="Diagram of isolation at the code location level"
src="/images/dagster-cloud/managing-deployments/isolation-level-code-locations.png"
width={1167}
height={384}
/>

If you have no specific requirements for isolation beyond the ability to deploy and run multiple projects, you can use a single agent and deployment to manage all your projects as individual code locations.

Pro:

- simplest and most cost-effective solution
- user access control can be set at the code location level
- single glass pane to view all assets

Con:

- no isolation between execution environments
- you need to use [SourceAsset to share assets across code locations](/concepts/assets/software-defined-assets#defining-external-asset-dependencies)

### Agent isolation

<Note>Agent queues are a Dagster Cloud Enterprise feature.</Note>

<Image
alt="Diagram of isolation at the agent level"
src="/images/dagster-cloud/managing-deployments/isolation-level-agents.png"
width={1331}
height={537}
/>

Using the [agent routing feature](/dagster-cloud/deployment/agents/running-multiple-agents#routing-requests-to-specific-agents), you can effectively isolate execution environments between projects by using a separate agent for each project.

Motivations for such a choice would include different compute requirements (different cloud providers, different architectures, etc.), optimizing for locality or access (running the data processing closer or in environment with access to the storage locations), etc.

Pro:

- isolation between execution environments
- user access control can be set at the code location level
- single glass pane to view all assets

Con:

- extra work to set up additional agents and agent queues

### Deployment isolation

<Note>
  Multiple deployments are only available in Dagster Cloud Enterprise.
</Note>

<Image
alt="Diagram of isolation at the Dagster Cloud deployment level"
src="/images/dagster-cloud/managing-deployments/isolation-level-deployments.png"
width={1152}
height={349}
/>

This is the most isolated solution. The typical motivation for this isolation level is to separate production and non-production environments. It may be considered to satisfy other organization specific requirements.

Pro:

- isolation between assets and execution environments
- user access control can be set at the code location and deployment level

Con:

- no single glass pane to view all assets (requires switching between multiple deployments in the UI)
