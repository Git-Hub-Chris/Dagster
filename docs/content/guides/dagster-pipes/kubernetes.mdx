---
title: "Integrating Kubernetes with Dagster Pipes | Dagster Docs"
description: "Learn to integrate Dagster Pipes with Kubernetes to launch external code from Dagster assets."
---

# Integrating Kubernetes with Dagster Pipes

<Note>
  <strong>Heads up!</strong> This guide focuses on using an out-of-the-box
  Kubernetes resource. For further customization, use the{" "}
  <a href="/guides/dagster-pipes/customizing-dagster-pipes-protocols">
    <code>open_pipes_session</code> approach
  </a>{" "}
  instead.
</Note>

In this guide, we’ll show you how to use [Dagster Pipes](/guides/dagster-pipes) with Dagster’s Kubernetes integration to launch Kubernetes pods and execute external code.

Pipes allows your Kubernetes code to execute outside of a full Dagster environment. Instead, the environment only needs to contain `dagster-pipes`, a single-file Python package with no dependencies that can be installed from PyPI or easily vendored. `dagster-pipes` handles streaming `stdout`/`stderr` and Dagster events back to the orchestration process.

---

## Prerequisites

To use Dagster Pipes with Kubernetes, you’ll need:

- **In the orchestration environment**, you'll need to install the following packages:

  ```shell
  pip install dagster dagster-webserver dagster-k8s kubernetes
  ```

  Refer to the [Dagster installation guide](/getting-started/install) for more info.

- **In Kubernetes:**
  - **An existing Kubernetes cluster.**
  - **The following information about your Kubernetes cluster**:
    - `config_file` - The name of the Kubernetes config file
    - `context` - The name of the Kubernetes context you want to use
    - `image` - The image you want to run using Dagster Pipes

---

## Step 1: Create an asset computed in Kubernetes

In this step, you’ll create a Dagster asset that, when materialized, opens a Dagster pipes session and spins up a Kubernetes pod that executes some external code.

### Step 1.1: Define the Dagster asset

In your Dagster project, create a file named `dagster_k8s_pipes.py` and paste in the following code:

```python
# dagster_k8s_pipes.py

from dagster import AssetExecutionContext, Definitions, asset
from dagster_k8s import PipesK8sClient


@asset
def k8s_pipes_asset(context: AssetExecutionContext, k8s_pipes_client: PipesK8sClient):
  return k8s_pipes_client.run(
      context=context,
      image="pipes-materialize:latest",
      kubeconfig_file=os.path.expanduser("~/.kube/config"),
      kube_context="<YOUR_CONTEXT_NAME>"
  ).get_materialize_result()
```

Here’s what we did in this example:

- Created an asset named `k8s_pipes_asset`

- Provided <PyObject object="AssetExecutionContext" /> as the `context` argument to the asset. This object provides access to system APIs such as resources, config, and logging.

- Specified a resource for the asset to use, <PyObject module="dagster_k8s" object="PipesK8sClient" />, which is a pre-built Dagster resource that allows you to quickly get Pipes working with your Kubernetes workspace.

  We also specified the following for the resource:

  - `context` - The asset's `context` (<PyObject object="AssetExecutionContext" />) data
  - `image` - The Kubernetes image we want to use
  - `kubeconfig_file` - A kube-config file containing authentication information to pass to `kubernetes.config.load_kube_config`
  - `kube_context` - A context argument to pass to `kubernetes.config.load_kube_config`

- Passed the `context`, `image`, `kubeconfig_file`, and `kube_context` to the `run` method of <PyObject module="dagster_k8s" object="PipesK8sClient" />. This method submits the provided cluster information to the Kubernetes API and then runs the specified `image`.

- Returned a <PyObject object="MaterializeResult" /> object representing the result of execution. This is obtained by calling `get_materialize_result` on the <PyObject module="dagster_pipes" object="PipesClientCompletedInvocation" /> object returned by `run` after the execution in Kubernetes has completed. **Note**: Execution can take several minutes even for trivial scripts due to cluster provisioning times.

### Step 1.2: Create Dagster Definitions

Next, you’ll add the asset and Kubernetes resource to your project’s code location via the <PyObject object="Definitions" /> object. This makes the resource available to other Dagster definitions in the project.

Copy and paste the following to the bottom of `dagster_k8s_pipes.py`:

```python
# dagster_k8s_pipes.py

defs = Definitions(
  assets=[k8s_pipes_asset],
  resources={
    "k8s_pipes_client": PipesK8sClient(),
  },
)
```

At this point, `dagster_k8s_pipes.py` should look like the following:

```python
# dagster_k8s_pipes.py

from dagster import AssetExecutionContext, Definitions, asset
from dagster_k8s import PipesK8sClient


@asset
def k8s_pipes_asset(context: AssetExecutionContext, k8s_pipes_client: PipesK8sClient):
  return k8s_pipes_client.run(
      context=context,
      image="pipes-materialize:latest",
      kubeconfig_file=os.path.expanduser("~/.kube/config"),
      kube_context="<YOUR_CONTEXT_NAME>"
  ).get_materialize_result()


defs = Definitions(
  assets=[k8s_pipes_asset],
  resources={
    "k8s_pipes_client": PipesK8sClient(),
  },
)
```

---

## Step 2: Write a script for execution on Kubernetes

The next step is to write the code that will be executed on Kubernetes.

TODO

```python
# my_python_script.py

from dagster_pipes import open_dagster_pipes

with open_dagster_pipes() as pipes:
    # Stream log message back to Dagster
    pipes.log.info(f"Using some_parameter value: {some_parameter_value}")

    # ... your code that computes and persists the asset

    # Stream asset materialization metadata and data version back to Dagster.
    # This should be called after you've computed and stored the asset value. We
    # omit the asset key here because there is only one asset in scope, but for
    # multi-assets you can pass an `asset_key` parameter.
    pipes.report_asset_materialization(
        metadata={
            "some_metric": {"raw_value": some_parameter_value + 1, "type": "int"}
        },
        data_version="alpha",
    )
```

Let's review what this code does:

- Imports <PyObject object="open_dagster_pipes" module="dagster_pipes" /> from `dagster_pipes`

- **Initializes the Dagster Pipes context (<PyObject object="open_dagster_pipes" module="dagster_pipes" />), which yields an instance of <PyObject object="PipesContext" module="dagster_pipes" /> called `pipes`.**

  We're using the default context loader (<PyObject object="PipesDefaultContextLoader" module="dagster_pipes" />) and message writer (<PyObject object="PipesDefaultMessageWriter" module="dagster_pipes" />) in this example. These objects establish communication between the orchestration and external process. On the orchestration end, these match a corresponding `PipesContextInjector` and `PipesMessageReader`, which are instantiated inside the <PyObject module="dagster_k8s" object="PipesK8sClient" />.

- **Inside the body of the context manager (<PyObject object="open_dagster_pipes" module="dagster_pipes" />), retrieve a log and report an asset materialization.** These calls use the temporary communications channels established by <PyObject object="PipesDefaultContextLoader" module="dagster_pipes" /> and <PyObject object="PipesDefaultMessageWriter" module="dagster_pipes" />. To see the full range of what you can do with the <PyObject object="PipesContext" module="dagster_pipes" />, see the API docs or the general [Pipes documentation](/guides/dagster-pipes).

At this point you can execute the rest of your Kubernetes code as normal, invoking various <PyObject object="PipesContext" module="dagster_pipes" /> APIs as needed.

#### Existing codebases

For illustrative purposes, we've created a Python script from scratch. However, you may want to apply Pipes to an existing codebase.

One approach that can be useful is to wrap the <PyObject object="open_dagster_pipes" module="dagster_pipes" /> context manager around an existing `main` function or entry point. You can either pass the <PyObject object="PipesContext" module="dagster_pipes" /> down through your business logic, or simply report an asset materialization after your business logic is done:

```python
from dagster_pipes import (
    PipesContextLoader,
    PipesMessageWriter,
    open_dagster_pipes,
)

# ... existing code

if __name__ == "__main__":
    with open_dagster_pipes(
        context_loader=PipesContextLoader(),
        message_writer=PipesMessageWriter(),
    ) as pipes:
        # ... existing logic
        pipes.report_asset_materialization(
            asset_key="raw_orders",
            metadata={"some_key": "some_value"},
            data_version="alpha",
        )
```

---

## Step 3: Launch the Kubernetes pod from the Dagster UI

In this step, you’ll run the Kubernetes pod you created in [Step 1.1](#step-11-define-the-dagster-asset) from the Dagster UI.

1. In a new command line session, run the following to start the UI:

   ```python
   dagster dev -f dagster_k8s_pipes.py
   ```

2. Navigate to [localhost:3000](http://localhost:3000/), where you should see the UI: \[SCREENSHOT]

3. Click **Materialize** near the top right corner of the page, then click **View** on the **Launched Run** popup. Wait for the run to complete, and the event log should look like this:

   <Image
   alt="Event log for Databricks run"
   src="/images/guides/dagster-pipes/databricks/run.png"
   width={2554}
   height={1335}
   />

---

## Related

<ArticleList>
  <ArticleListItem
    title="Dagster Pipes"
    href="/guides/dagster-pipes"
  ></ArticleListItem>
  <ArticleListItem
    title="Dagster Pipes details and customization"
    href="/guides/dagster-pipes/dagster-pipes-details-and-customization"
  ></ArticleListItem>
  <ArticleListItem
    title="dagster-k8s API reference"
    href="/_apidocs/libraries/dagster-k8s"
  ></ArticleListItem>
</ArticleList>
