---
title: External Assets | Dagster
description: External assets model assets in Dagster that are not scheduled or materialized in Dagster.
---

# External Assets (Experimental)

An external asset is an asset that is not materialized by Dagster, but is tracked in the asset graph and asset catalog. This allows you to model assets in Dagster, attach metadata and events to those assets, but without scheduling their materialization with Dagster.

Example use cases:

- Data landed by an external source (e.g. a external file landing daily; Kafka landing data into Amazon S3)
- Data created and processed using manual processes
- Data materialized by existing pipelines with their own scheduling and infrastructure that you do not want to or need to migrate en masse.

With an external asset you can:

- Attach metadata to its definition for documentation, tracking ownership, and so on
- Track its data quality in Dagster
- Track its data version in Dagster
- Use asset sensors or auto-materialize policies to update downstream assets based on updates to external assets

You cannot, however:

- Schedule an external asset's materialiation
- Backfill an external asset using Dagster
- Use the Dagster UI or GraphQL API to instigate ad hoc materializations.

---

## Relevant APIs

| Name                                             | Description                                                                                 |
| ------------------------------------------------ | ------------------------------------------------------------------------------------------- |
| <PyObject object="external_assets_from_specs" /> | Create list of <PyObject object="AssetsDefinition"/> objects that represent external assets |
| <PyObject object="AssetSpec" />                  | An object that represents the metadata of a particular asset                                |

---

### What about Source Assets?

A common use case for external assets is modeling data produced by an process not under Dagster's control. For example a daily drop of a file from a third party in s3.

In most systems these are described as sources. This includes Dagster, which includes <PyObject object="SourceAsset" displayText="SourceAsset" /> which will be supplanted by external assets in the near-term future, as external assets are a superset of the functionality of Source Assets.

## Defining External Assets

### A single external asset

The following code declares a single external asset that represents a file in S3, and passes it to <PyObject object="Definitions"/>

```python file=/concepts/assets/external_assets/single_declaration.py
from dagster import AssetSpec, Definitions, external_asset_from_spec

defs = Definitions(assets=[external_asset_from_spec(AssetSpec("file_in_s3"))])
```

### External assets with dependencies

External assets can depend on other external assets. This is accomplished by using the `deps` argument of <PyObject object="AssetSpec" />. This enables Dagster to model entire graphs of assets scheduled and orchesrated by other systems. For example, in this scenario you have a "raw_logs" assets "processed_logs". The processed log asset is produced by a scheduled computation in another orchestration system. External assets allows you to model both assets in Dagster.\\

```python file=/concepts/assets/external_assets/external_asset_deps.py
from dagster import AssetSpec, Definitions, external_assets_from_specs

raw_logs = AssetSpec("raw_logs")
processed_logs = AssetSpec("processed_logs", deps=[raw_logs])

defs = Definitions(assets=external_assets_from_specs([raw_logs, processed_logs]))
```

External assets cannot depend on non-external assets.

### Fully managed assets can depend on External Assets

Fully managed assets can depend on external assets. In this example we author an asset, "aggregated_logs", which depends on "processed_logs", an external asset.

```python file=/concepts/assets/external_assets/normal_asset_depending_on_external.py
from dagster import AssetSpec, Definitions, asset, external_assets_from_specs

raw_logs = AssetSpec("raw_logs")
processed_logs = AssetSpec("processed_logs", deps=[raw_logs])


@asset(deps=[processed_logs])
def aggregated_logs() -> None:
    # Loads "processed_log" into memory and performs some aggregation
    ...


defs = Definitions(
    assets=[aggregated_logs, *external_assets_from_specs([raw_logs, processed_logs])]
)
```

---

## Keeping an external asset's metadata up to date

Since Dagster does not control scheduling or materializing external assets, it is up to the user to keep the metadata for an external asset up-to-date. There are a number of mechanisms for doing so:

- REST APIs
- Sensors
- Log events in ops

### Using the REST API

Dagster OSS exposes a REST endpoint for reporting asset materializations.

The following demonstrates using an a `curl` command in a shell script:

```bash
curl --request POST \
    --url https://path/to/instance/report_asset_materialization/{asset_key}\
    --header 'Content-Type: application/json' \
    --data '{
    "metadata" : {
        "source": "From curl command
    }
}'
```

The following demonstrates invoking the API in Python using the `requests` library:

```python
import requests

url = f"https://path/to/instance/report_asset_materialization/{asset_key}"
payload = { "metadata": { "source": "From python script" } }
headers = { "Content-Type": "application/json" }

response = requests.request("POST", url, json=payload, headers=headers)
```

There are also end points for reporting asset observations and asset check evaluations.

### Using sensors

You can generate events to attach to external assets and provide them to sensors directly, by using the `asset_events` parameter of <PyObject object="SensorResult"/>.

```python file=/concepts/assets/external_assets/external_asset_using_sensor.py
import datetime

from dagster import (
    AssetMaterialization,
    AssetSpec,
    Definitions,
    SensorEvaluationContext,
    SensorResult,
    external_asset_from_spec,
    sensor,
)


def utc_now_str() -> str:
    return datetime.datetime.now(datetime.timezone.utc).strftime("%Y-%m-%d, %H:%M:%S")


@sensor()
def keep_external_asset_a_up_to_date(context: SensorEvaluationContext) -> SensorResult:
    # Materialization happened in external system, but is recorded here
    return SensorResult(
        asset_events=[
            AssetMaterialization(
                asset_key="external_asset_a",
                metadata={
                    "source": f'From sensor "{context.sensor_name}" at UTC time "{utc_now_str()}"'
                },
            )
        ]
    )


defs = Definitions(
    assets=[external_asset_from_spec(AssetSpec("external_asset_a"))],
    sensors=[keep_external_asset_a_up_to_date],
)
```

### Using the Python API

You can insert events to attach to external assets directly from Dagster's Python API. An example where this would be useful is writing a hand-rolled Python script to backfill metadata. The relevant API is `report_runless_asset_event` on <PyObject object="DagsterInstance"/>.

```python file=/concepts/assets/external_assets/external_asset_events_using_python_api.py startafter=start_python_api_marker endbefore=end_python_api_marker dedent=4
from dagster import AssetMaterialization

# instance is a DagsterInstance. Get using DagsterInstance.get()
instance.report_runless_asset_event(
    AssetMaterialization(
        "asset_one", metadata={"nrows": 10, "source": "From this script."}
    )
)
```

### Logging events in unrelated ops

You can log an <PyObject object="AssetMaterialization"/> from a bare op. In this case, use the `log_event` method of <PyObject object="OpExecutionContext"/> to report an asset materialization of an external asset.

```python file=/concepts/assets/external_assets/update_external_asset_via_op.py
from dagster import (
    AssetMaterialization,
    AssetSpec,
    Definitions,
    OpExecutionContext,
    external_asset_from_spec,
    job,
    op,
)


@op
def an_op(context: OpExecutionContext) -> None:
    context.log_event(AssetMaterialization(asset_key="external_asset"))


@job
def a_job() -> None:
    an_op()


defs = Definitions(
    assets=[external_asset_from_spec(AssetSpec("external_asset"))], jobs=[a_job]
)
```
