---
title: Resources | Dagster
description: Resources enable you to separate graph logic from environment, and therefore make it easier to test and develop graphs in various environments.
---

# Resources

Resources are objects that are shared across the implementations of multiple [software-defined assets](/concepts/assets/software-defined-assets) and [ops](/concepts/ops-jobs-graphs/ops) and that can be plugged in after defining those ops and assets.

Resources typically model external components that assets and ops interact with. For example, a resource might be a connection to a data warehouse like Snowflake or a service like Slack.

So, why use resources?

- **Plug in different implementations in different environments** - If you have a heavy external dependency that you want to use in production, but avoid using in testing, you can accomplish this by providing different resources in each environment. Check out [Separating Business Logic from Environments](/concepts/testing#separating-business-logic-from-environments) for more info about this capability.
- **Share configuration across multiple ops or assets** - Resources are configurable and shared, so you can supply configuration in one place instead of configuring the ops and assets individually.
- **Share implementations across multiple ops or assets** - When multiple ops access the same external services, resources provide a standard way to structure your code to share the implementations.

---

## Relevant APIs

| Name                                             | Description                                                                                                                                                                                                                 |
| ------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <PyObject object="resource" decorator />         | The decorator used to define resources. The decorated function is called a `resource_fn`. The decorator returns a <PyObject object="ResourceDefinition" />.                                                                 |
| <PyObject object="ResourceDefinition" />         | Class for resource definitions. You almost never want to use initialize this class directly. Instead, you should use the <PyObject object="resource" decorator /> which returns a <PyObject object="ResourceDefinition" />. |
| <PyObject object="InitResourceContext"/>         | The context object provided to a resource during initialization. This object contains required resource, config, and other run information.                                                                                 |
| <PyObject object="build_init_resource_context"/> | Function for building an <PyObject object="InitResourceContext"/> outside of execution, intended to be used when testing a resource.                                                                                        |
| <PyObject object="build_resources"/>             | Function for initializing a set of resources outside of the context of a job's execution.                                                                                                                                   |
| <PyObject object="with_resources"/>              | Function for providing resources to software-defined assets and source assets.                                                                                                                                              |

---

## Using resources

### Getting started using resources

Any Python object can be used as a resource. Software-defined assets and ops specify resource dependencies by annotating the resource as a parameter to the asset or op function.

To provide resources to your assets and ops, attach them to your <PyObject object="Definitions" /> call. These resources are automatically passed to the function at runtime.

<TabGroup persistentKey="assetsorops">
<TabItem name="Using software-defined-assets">

#### Using software-defined assets

```python file=/concepts/resources/resources.py startafter=start_new_resources_assets_defs endbefore=end_new_resources_assets_defs
from dagster import asset, Definitions
from dagster._core.definitions.resource_annotation import Resource


@asset
def data_from_url(url: Resource[str]) -> Dict[str, Any]:
    return requests.get(url).json()


defs = Definitions(
    assets=[data_from_url],
    resources={"url": "https://dagster.io"},
)
```

</TabItem>
<TabItem name="Using ops and jobs">

#### Using ops

```python file=/concepts/resources/resources.py startafter=start_new_resources_ops_defs endbefore=end_new_resources_ops_defs
from dagster import op, Definitions, job
from dagster._core.definitions.resource_annotation import Resource


@op
def print_url_from_resource(url: Resource[str]):
    print(f"Visit {url}")


@job
def print_url_job():
    print_url_from_resource()


defs = Definitions(
    jobs=[print_url_job],
    resources={"url": "https://dagster.io"},
)
```

</TabItem>
</TabGroup>

### Configurable resources

In many cases, resources need to be [configurable](/concepts/configuration/config-schema). For example, a resource representing a connection to an external service may need a configurable username and password. Configurable resources can be defined by extending the <PyObject object="ConfigurableResource"/> class. The attributes on the class are used to define the configuration schema, which lets you customize behavior through run configuration.

<TabGroup persistentKey="assetsorops">
<TabItem name="Using software-defined-assets">

#### Using software-defined assets

```python file=/concepts/resources/resources.py startafter=start_new_resources_configurable_defs endbefore=end_new_resources_configurable_defs
from dagster import asset, Definitions
from dagster._config.structured_config import ConfigurableResource


class MyConnectionResource(ConfigurableResource):
    username: str
    password: str

    def request(self, endpoint: str) -> Response:
        return requests.get(
            f"https://my-api.com/{endpoint}",
            auth=(self.username, self.password),
        )


# Since MyConnectionResource is a ConfigurableResource, we don't
# need to wrap it in a Resource[] annotation.
@asset
def data_from_service(my_conn: MyConnectionResource) -> Dict[str, Any]:
    return my_conn.request("/fetch_data").json()


defs = Definitions(
    assets=[data_from_service],
    resources={
        "my_conn": MyConnectionResource(username="my_user", password="my_password"),
    },
)
```

</TabItem>
<TabItem name="Using ops and jobs">

#### Using ops

```python file=/concepts/resources/resources.py startafter=start_new_resources_configurable_defs_ops endbefore=end_new_resources_configurable_defs_ops
from dagster import Definitions, job, op
from dagster._config.structured_config import ConfigurableResource


class MyConnectionResource(ConfigurableResource):
    username: str
    password: str

    def request(self, endpoint: str) -> Response:
        return requests.get(
            f"https://my-api.com/{endpoint}",
            auth=(self.username, self.password),
        )


# Since MyConnectionResource is a ConfigurableResource, we don't
# need to wrap it in a Resource[] annotation.
@op
def update_service(my_conn: MyConnectionResource):
    my_conn.request("/update")


@job
def update_service_job():
    update_service()


defs = Definitions(
    jobs=[update_service_job],
    resources={
        "my_conn": MyConnectionResource(username="my_user", password="my_password"),
    },
)
```

</TabItem>
</TabGroup>

---


## Resources which depend on other resources

In some situations, your resource may depend on other resources. For example, a resource representing a connection to an external service may rely on a resource representing credentials for that service. In this case, you can list that nested resource as an attribute of your resource class.

```python file=/concepts/resources/resources.py startafter=start_new_resources_nesting endbefore=end_new_resources_nesting
from dagster import Definitions
from dagster._config.structured_config import ConfigurableResource


class CredentialsResource(ConfigurableResource):
    username: str
    password: str


class FileStoreBucket(ConfigurableResource):
    credentials: CredentialsResource
    region: str

    def write(self, data: str):
        get_filestore_client(
            username=self.credentials.username,
            password=self.credentials.password,
            region=self.region,
        ).write(data)


credentials = CredentialsResource(username="my_user", password="my_password")
defs = Definitions(
    assets=[...],
    resources={
        "bucket": FileStoreBucket(
            credentials=credentials,
            region="us-east-1",
        ),
    },
)
```

If we instead would like the configuration for our credentials to be provided at runtime, we can use the `configure_at_launch()` method to defer the construction of the `CredentialsResource` until runtime. To allow configuration of the `CredentialsResource` in the launchpad at runtime, we must also specify the `credentials` resource to our `Definitions` object.

```python file=/concepts/resources/resources.py startafter=start_resource_dep_job_runtime endbefore=end_resource_dep_job_runtime
credentials = CredentialsResource.configure_at_launch()


defs = Definitions(
    assets=[...],
    resources={
        "credentials": credentials,
        "bucket": FileStoreBucket(
            credentials=credentials,
            region="us-east-1",
        ),
    },
)
```

---

## Testing configurable resources

You can test the initialization of a <PyObject object="ConfigurableResource"/> by constructing it manually. In most cases, you can construct your resource directly:

```python file=/concepts/resources/resources.py startafter=start_resource_testing endbefore=end_resource_testing
from dagster._config.structured_config import ConfigurableResource


class MyResource(ConfigurableResource):
    def get_value(self) -> str:
        return "foo"


def test_my_resource():
    assert MyResource().get_value() == "foo"
```

If your resource requires other resources, then you can pass them as constructor arguments.

```python file=/concepts/resources/resources.py startafter=start_resource_testing_with_context endbefore=end_resource_testing_with_context
from dagster._config.structured_config import ConfigurableResource


class StringHolderResource(ConfigurableResource):
    value: str


class MyResourceRequiresAnother(ConfigurableResource):
    foo: StringHolderResource
    bar: str


def test_my_resource_with_context():
    resource = MyResourceRequiresAnother(foo=StringHolderResource("foo"), bar="bar")
    assert resource.foo.value == "foo"
    assert resource.bar == "bar"
```

---

## See it in action

For more examples of resources, check out the following in our [Hacker News example](https://github.com/dagster-io/dagster/tree/master/examples/project_fully_featured):

- [Resource that fetches from the Hacker News API](https://github.com/dagster-io/dagster/blob/master/examples/project_fully_featured/project_fully_featured/resources/hn_resource.py)
- [Using a resource in an asset](https://github.com/dagster-io/dagster/blob/master/examples/project_fully_featured/project_fully_featured/assets/core/items.py)
