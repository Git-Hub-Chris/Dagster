---
title: Resources | Dagster
description: Resources enable you to separate graph logic from environment, and therefore make it easier to test and develop graphs in various environments.
---

# Resources

Resources are objects that are shared across the implementations of multiple [software-defined assets](/concepts/assets/software-defined-assets) and [ops](/concepts/ops-jobs-graphs/ops) and that can be plugged in after defining those ops and assets.

Resources typically model external components that assets and ops interact with. For example, a resource might be a connection to a data warehouse like Snowflake or a service like Slack.

So, why use resources?

- **Plug in different implementations in different environments** - If you have a heavy external dependency that you want to use in production, but avoid using in testing, you can accomplish this by providing different resources in each environment. Check out [Separating Business Logic from Environments](/concepts/testing#separating-business-logic-from-environments) for more info about this capability.
- **Share configuration across multiple ops or assets** - Resources are configurable and shared, so you can supply configuration in one place instead of configuring the ops and assets individually.
- **Share implementations across multiple ops or assets** - When multiple ops access the same external services, resources provide a standard way to structure your code to share the implementations.

---

## Using resources

### Getting started using resources

Any Python object can be used as a resource. Software-defined assets and ops specify resource dependencies by annotating the resource as a parameter to the asset or op function. The parameter type should be wrapped in a <PyObject object="Resource"/> annotation to indicate that it is a resource and not an upstream asset or op input.

To provide resource values to your assets and ops, attach them to your <PyObject object="Definitions" /> call. These resources are automatically passed to the function at runtime.

<TabGroup persistentKey="assetsorops">
<TabItem name="Using software-defined-assets">

#### Using software-defined assets

```python file=/concepts/resources/resources.py startafter=start_new_resources_assets_defs endbefore=end_new_resources_assets_defs
No match for startAfter value "start_new_resources_assets_defs"
```

</TabItem>
<TabItem name="Using ops and jobs">

#### Using ops

```python file=/concepts/resources/resources.py startafter=start_new_resources_ops_defs endbefore=end_new_resources_ops_defs
No match for startAfter value "start_new_resources_ops_defs"
```

</TabItem>
</TabGroup>

### Configurable resources

In many cases, resources need to be [configurable](/concepts/configuration/config-schema). For example, a resource representing a connection to an external service may need a configurable username and password. Configurable resources can be defined by extending the <PyObject object="ConfigurableResource"/> class. The attributes on the class are used to define the configuration schema, which lets you customize behavior through run configuration.

<TabGroup persistentKey="assetsorops">
<TabItem name="Using software-defined-assets">

#### Using software-defined assets

```python file=/concepts/resources/resources.py startafter=start_new_resources_configurable_defs endbefore=end_new_resources_configurable_defs
No match for startAfter value "start_new_resources_configurable_defs"
```

</TabItem>
<TabItem name="Using ops and jobs">

#### Using ops

```python file=/concepts/resources/resources.py startafter=start_new_resources_configurable_defs_ops endbefore=end_new_resources_configurable_defs_ops
No match for startAfter value "start_new_resources_configurable_defs_ops"
```

</TabItem>
</TabGroup>

---

## Using environment variables with resources

Resources can be configured using environment variables, which is useful for secrets or other environment-specific configuration. To use environment variables, pass an <PyObject object="EnvVar" /> when constructing your resource.

```python file=/concepts/resources/resources.py startafter=start_new_resources_env_vars endbefore=end_new_resources_env_vars
No match for startAfter value "start_new_resources_env_vars"
```

---

## Resources which depend on other resources

In some situations, your resource may depend on other resources. For example, a resource representing a connection to an external service may rely on a resource representing credentials for that service. In this case, you can list that nested resource as an attribute of your resource class.

```python file=/concepts/resources/resources.py startafter=start_new_resources_nesting endbefore=end_new_resources_nesting
No match for startAfter value "start_new_resources_nesting"
```

If we instead would like the configuration for our credentials to be provided at runtime, we can use the `configure_at_launch()` method to defer the construction of the `CredentialsResource` until runtime. To allow configuration of the `CredentialsResource` in the launchpad at runtime, we must also specify the `credentials` resource to our `Definitions` object.

```python file=/concepts/resources/resources.py startafter=start_resource_dep_job_runtime endbefore=end_resource_dep_job_runtime
No match for startAfter value "start_resource_dep_job_runtime"
```

---

## Testing configurable resources

You can test the initialization of a <PyObject object="ConfigurableResource"/> by constructing it manually. In most cases, you can construct your resource directly:

```python file=/concepts/resources/resources.py startafter=start_resource_testing endbefore=end_resource_testing
from dagster import resource


@resource
def my_resource(_):
    return "foo"


def test_my_resource():
    assert my_resource(None) == "foo"
```

If your resource requires other resources, then you can pass them as constructor arguments.

```python file=/concepts/resources/resources.py startafter=start_resource_testing_with_context endbefore=end_resource_testing_with_context
from dagster import build_init_resource_context, resource


@resource(required_resource_keys={"foo"}, config_schema={"bar": str})
def my_resource_requires_context(init_context):
    return init_context.resources.foo, init_context.resource_config["bar"]


def test_my_resource_with_context():
    init_context = build_init_resource_context(
        resources={"foo": "foo_str"}, config={"bar": "bar_str"}
    )
    assert my_resource_requires_context(init_context) == ("foo_str", "bar_str")
```

---

## See it in action

For more examples of resources, check out the following in our [Hacker News example](https://github.com/dagster-io/dagster/tree/master/examples/project_fully_featured):

- [Resource that fetches from the Hacker News API](https://github.com/dagster-io/dagster/blob/master/examples/project_fully_featured/project_fully_featured/resources/hn_resource.py)
- [Using a resource in an asset](https://github.com/dagster-io/dagster/blob/master/examples/project_fully_featured/project_fully_featured/assets/core/items.py)
