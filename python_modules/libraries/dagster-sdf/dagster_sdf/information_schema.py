from pathlib import Path
from typing import Dict, Literal, Optional, Set, Tuple, Union

import dagster._check as check
import polars as pl
from dagster import AssetKey, AssetOut, Nothing
from dagster._record import IHaveNew, record_custom

from .asset_utils import dagster_name_fn
from .constants import (
    DEFAULT_SDF_WORKSPACE_ENVIRONMENT,
    SDF_INFORMATION_SCHEMA_TABLES,
    SDF_TARGET_DIR,
)
from .dagster_sdf_translator import DagsterSdfTranslator


def get_info_schema_dir(target_dir: Path, environment: str) -> Path:
    return target_dir.joinpath(
        SDF_TARGET_DIR, environment, "data", "system", "information_schema::sdf"
    )


@record_custom(checked=False)
class SdfInformationSchema(IHaveNew):
    """A class to represent the SDF information schema.

    The information schema is a set of tables that are generated by the sdf cli on compilation.
    It can be queried directly via the sdf cli, or by reading the parquet files that live in the
    `sdftarget` directory.

    This class specifically interfaces with the tables and columns tables, which contain metadata
    on their upstream and downstream dependencies, as well as their schemas, descriptions, classifiers,
    and other metadata.

    Read more about the information schema here: https://docs.sdf.com/reference/sdf-information-schema#sdf-information-schema

    Args:
        workspace_dir (Union[Path, str]): The path to the workspace directory.
        target_dir (Union[Path, str]): The path to the target directory.
        environment (str, optional): The environment to use. Defaults to "dbg".
    """

    information_schema_dir: Path
    information_schema: Dict[str, pl.DataFrame]

    def __new__(
        cls,
        workspace_dir: Union[Path, str],
        target_dir: Union[Path, str],
        environment: str = DEFAULT_SDF_WORKSPACE_ENVIRONMENT,
    ):
        check.inst_param(workspace_dir, "workspace_dir", (str, Path))
        check.inst_param(target_dir, "target_dir", (str, Path))
        check.str_param(environment, "environment")

        workspace_dir = Path(workspace_dir)
        target_dir = Path(target_dir)

        information_schema_dir = get_info_schema_dir(target_dir, environment)
        check.invariant(
            information_schema_dir.exists(),
            f"Information schema directory {information_schema_dir} does not exist.",
        )

        return super().__new__(
            cls,
            information_schema_dir=information_schema_dir,
            information_schema={},
        )

    def read_table(
        self, table_name: Literal["tables", "columns", "table_lineage", "column_lineage"]
    ) -> pl.DataFrame:
        check.invariant(
            table_name in SDF_INFORMATION_SCHEMA_TABLES,
            f"Table `{table_name}` is not valid information schema table."
            f" Select from one of {SDF_INFORMATION_SCHEMA_TABLES}.",
        )

        return self.information_schema.setdefault(
            table_name, pl.read_parquet(self.information_schema_dir.joinpath(table_name))
        )

    def build_sdf_multi_asset_args(
        self, io_manager_key: Optional[str], dagster_sdf_translator: DagsterSdfTranslator
    ) -> Tuple[Dict[str, AssetOut], Dict[str, Set[AssetKey]]]:
        outs: Dict[str, AssetOut] = {}
        internal_asset_deps: Dict[str, Set[AssetKey]] = {}

        for table_row in self.read_table("tables").rows(named=True):
            if table_row["purpose"] in ["system", "external-system"]:
                continue
            asset_key = dagster_sdf_translator.get_asset_key(table_row["table_id"])
            output_name = dagster_name_fn(table_row["table_id"])
            outs[output_name] = AssetOut(
                key=asset_key,
                dagster_type=Nothing,
                io_manager_key=io_manager_key,
                description=table_row["description"],
                is_required=False,
            )
            internal_asset_deps[output_name] = {
                dagster_sdf_translator.get_asset_key(dep) for dep in table_row["depends_on"]
            }

        return outs, internal_asset_deps

    def is_hydrated(self) -> bool:
        for table in SDF_INFORMATION_SCHEMA_TABLES:
            if not any(self.information_schema_dir.joinpath(table).iterdir()):
                return False
        return True
